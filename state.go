// MIT License: https://github.com/hhassoubi/go-statechart/blob/master/LICENSE
// Copyright (c) 2023 Hicham Hassoubi

package statechart

// The Event interface
// This is need needed to avoid casting interface{} to concrete Event
type Event interface {
	// A trick to make sure that only events can be used as events.
	isEvent() bool
}

// Event Type Parameter Constraint. This is a trick to force event to be passed by pointer
// `E` is the concrete event
type EventCst[E any] interface {
	*E
	Event
}

// Action Type function that takes the a pointer to Event as argument
// `E` the event type
// `PE` is deducted (Pointer to E)
// `event` the event that triggered this action
type Action[E any, PE EventCst[E]] func(event PE)

// the abstract Action
// `event` the event that triggered this action
type BaseAction func(event Event)

// A function that convert an Action to a BaseAction.
// the new generated function will perform a safe down cast
// `action` the concrete action
// returns the abstract action
func ToBaseAction[E any, PE EventCst[E]](action Action[E, PE]) BaseAction {
	if action == nil {
		return nil
	}
	return func(e Event) {
		action(e.(PE))
	}
}

// the state enter action
type EntryAction func()

// the state exit action
type ExitAction func()

type ResultType int16

const (
	// Forwards the event to the parent state
	FORWARD ResultType = iota
	// Discards the event
	DISCARD
	// Transit to a new state
	TRANSIT
	// defer the event to be posted after state change
	DEFER
)

// encapsulate the result for a reaction
type ReactionResult struct {
	status      ResultType
	targetState interface{} // Proxy to the target state
	action      BaseAction  // transition Action
}

// Custom reaction function type.
type Reaction[T any, PT EventCst[T]] func(PT) ReactionResult

// This is used to link an event to a custom reaction
type EventReaction struct {
	reaction      func(Event) ReactionResult
	eventSelector func(Event) bool
}

// makes an EventReaction from a custom reaction
func MakeEventReaction[T any, PT EventCst[T]](reaction Reaction[T, PT]) EventReaction {
	if reaction == nil {
		return EventReaction{}
	}
	return EventReaction{
		reaction: func(e Event) ReactionResult {
			return reaction(e.(PT))
		},
		eventSelector: func(e Event) bool {
			_, ok := e.(PT)
			return ok
		},
	}
}

// The State[C] Interface where `C` is the user context
type State[C any] interface {
	isState() bool
	Setup(proxy StateSetupProxy[C]) (EntryAction, ExitAction)
}

// The State identifier generated by the state machine when calling AddState
type StateId int

// State Type Parameter Constraint.
// `S` is the actual user state
// `C` is the user context
type StateCst[S any, C any] interface {
	*S
	State[C]
}

// StateProxy is a proxy for a state machine and state container. This is the main
// mechanisms to access the state machine
type StateProxy[C any] interface {
	// Returns the name of the State
	Name() string
	// Returns an ancestor of the current state
	GetAncestor(state StateId) State[C]
	// Returns the user context
	GetContext() *C
	// Find the StateId of a state in the state machine
	// It is ok to cache the stateId, to improve performance
	// `selector` a function that is used to test if a state is a match
	FindStateId(selector func(state State[C]) bool) StateId
	// Create a transition result (only needed for custom reactions)
	Transit(state StateId, action BaseAction) ReactionResult
	// Create a forward result (only needed for custom reactions)
	Forward() ReactionResult
	// Create a discard result (only needed for custom reactions)
	Discard() ReactionResult
	// Create a defer result (only needed for custom reactions)
	Defer() ReactionResult
	// Post an event to the event queue that will be processed after the current reaction
	PostEvent(event Event)
}

// Finds the state id of the state that matches the Concrete State Type
// `S` is the actual user state
// `C` is the user context (deducted)
// `PS` is a pointer to `S` (deducted)
// `proxy` is the proxy to the internal state in the machine
func FindStateId[S any, C any, PS StateCst[S, C]](proxy StateProxy[C]) StateId {
	selector := GeneticStateSelector[S, C, PS]
	return proxy.FindStateId(selector)
}

// `StateSetupProxy` is a `StateProxy` that can add reactions and set the starting state.
type StateSetupProxy[C any] interface {
	StateProxy[C]
	// Set the name of the state ( the default name is from reflect.TypeOf().Name() )
	SetName(string)
	// Add a state reaction
	AddReaction(reaction EventReaction)
	// Set a starting state (used for supper state)
	SetStartingState(state StateId)
}

// Set a starting state using a State Type as a key
// `S` is the actual user state
// `C` is the user context (deducted)
// `PS` is a pointer to `S` (deducted)
// `proxy` is the proxy to the internal state in the machine
func SetStartingState[S any, C any, PS StateCst[S, C]](state StateSetupProxy[C]) {
	id := FindStateId[S, C, PS](state)
	state.SetStartingState(id)
}

// Add a simple state transition
// `E` is the event type
// `S` is the actual user state that we are going to
// `C` is the user context (deducted)
// `PE` is a pointer to E (deducted)
// `PS` is a pointer to `S` (deducted)
// `from` is the proxy of the current state
// `action` is the action associated with the transition (optional)
func AddSimpleStateTransition[E any, S any, C any, PE EventCst[E], PS StateCst[S, C]](from StateSetupProxy[C], action Action[E, PE]) {
	toId := FindStateId[S, C, PS](from)
	reaction := func(e PE) ReactionResult {
		return from.Transit(toId, ToBaseAction(action))
	}
	from.AddReaction(MakeEventReaction(reaction))
}

// Add a custom reaction
// `E` is the event type
// `C` is the user context (deducted)
// `PE` is a pointer to E (deducted)
// `from` is the proxy of the current state
// `reaction` is the custom reaction function
func AddCustomStateReaction[E any, C any, PE EventCst[E]](from StateSetupProxy[C], reaction Reaction[E, PE]) {
	from.AddReaction(MakeEventReaction(reaction))
}

// Add an in-state reaction
// `E` is the event type
// `C` is the user context (deducted)
// `PE` is a pointer to E (deducted)
// `state` is the proxy of the current state
// `action` is the action function
func AddInStateReaction[E any, C any, PE EventCst[E]](state StateSetupProxy[C], action Action[E, PE]) {
	reaction := func(e PE) ReactionResult {
		action(e)
		return ReactionResult{status: DISCARD}
	}
	state.AddReaction(MakeEventReaction(reaction))
}

// Add a discard event reaction
// `E` is the event type
// `C` is the user context (deducted)
// `PE` is a pointer to E (deducted)
// `state` is the proxy of the current state
func AddDiscard[E any, C any, PE EventCst[E]](state StateSetupProxy[C]) {
	reaction := func(e PE) ReactionResult {
		return ReactionResult{status: DISCARD}
	}
	state.AddReaction(MakeEventReaction(reaction))
}

// Returns true if the state is of type `*S`
// This is used to find a state by Type
// `S` is the actual user state
// `C` is the user context (deducted)
// `PS` is pointer to S (deducted)
func GeneticStateSelector[S any, C any, PS StateCst[S, C]](state State[C]) bool {
	if _, ok := state.(PS); ok {
		return true
	}
	return false
}

// Default implementation of State[C], This could be used to simplify the API in the concrete state
type StateDefault[C any] struct {
	proxy StateProxy[C]
}

func (*StateDefault[C]) isState() bool {
	return true
}

func (s *StateDefault[C]) GetContext() *C {
	return s.proxy.GetContext()
}
func (s *StateDefault[C]) GetAncestor(state StateId) State[C] {
	return s.proxy.GetAncestor(state)
}

// Initializing the state.
func (s *StateDefault[C]) Init(proxy StateProxy[C]) {
	s.proxy = proxy
}

func (s *StateDefault[C]) Proxy() StateProxy[C] {
	return s.proxy
}

type EventDefault struct {
}

func (e *EventDefault) isEvent() bool {
	return true
}
