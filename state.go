// MIT License: https://github.com/hhassoubi/go-statechart/blob/master/LICENSE
// Copyright (c) 2023 Hicham Hassoubi

package statechart

// The Event interface
// This is need needed to avoid casting interface{} to concrete Event
type Event interface {
	// A trick to make sure that only events can be used as events.
	isEvent() bool
}

// Event Type Parameter Constraint. This is a trick to force event to be passed by pointer
// `E` is the concrete event
type EventCst[E any] interface {
	*E
	Event
}

// Action Type function that takes the a pointer to Event as argument
// `E` the event type
// `PE` is deducted (Pointer to E)
type Action[E any, PE EventCst[E]] func(event PE)

// the abstract Action
type BaseAction func(event Event)

// A function that convert an Action to a BaseAction.
// the new generated function will perform a down cast (safe)
func ToBaseAction[E any, PE EventCst[E]](action Action[E, PE]) BaseAction {
	if action == nil {
		return nil
	}
	return func(e Event) {
		action(e.(PE))
	}
}

// the state enter action
type EntryAction func()

// the state exit action
type ExitAction func()

type ResultType int16

const (
	// Now, the index starts from 1
	FORWARD ResultType = iota
	DISCARD
	TRANSIT
	DEFER
)

// return result for a reaction
type ReactionResult struct {
	status      ResultType
	targetState interface{} // Proxy to the target state
	action      BaseAction  // transition Action
}

// Custom reaction function type.
type Reaction[T any, PT EventCst[T]] func(PT) ReactionResult

// This is used to link an event to a custom reaction
type EventReaction struct {
	reaction      func(Event) ReactionResult
	eventSelector func(Event) bool
}

// makes an EventReaction from a custom reaction
func MakeEventReaction[T any, PT EventCst[T]](reaction Reaction[T, PT]) EventReaction {
	if reaction == nil {
		return EventReaction{}
	}
	return EventReaction{
		reaction: func(e Event) ReactionResult {
			return reaction(e.(PT))
		},
		eventSelector: func(e Event) bool {
			_, ok := e.(PT)
			return ok
		},
	}
}

// The State[C] Interface where `C` is the user context
type State[C any] interface {
	isState() bool
	Setup(proxy StateSetupProxy[C]) (EntryAction, ExitAction)
}

// The State identifier generated by the state machine when calling AddState
type StateId int

// State Type Parameter Constraint.
// `S` is the actual user state
// `C` is the user context
type StateCst[S any, C any] interface {
	*S
	State[C]
}

// `StateProxy` is a proxy for a state machine that allows you to transition between states and get
// information about the state machine.
//
// The `Transit` method is used to transition between states. The `GetAncestor` method is used to get an
// ancestor state from the state machine. The `GetContext` method is used to get the context of the state
// machine. The `FindStateId` method is used to find a state id in the state machine.
type StateProxy[C any] interface {
	Name() string
	GetAncestor(state StateId) State[C]
	GetContext() *C
	FindStateId(selector func(state State[C]) bool) StateId
	Transit(state StateId, action BaseAction) ReactionResult
	Forward() ReactionResult
	Discard() ReactionResult
	Defer() ReactionResult
}

// Finds the state id of the state that matches the State Type
// `S` is the actual user state
// `C` is the user context
// `PS` is deducted (pointer to `S`)
// `proxy` is the proxy to the internal state in the machine
func FindStateId[S any, C any, PS StateCst[S, C]](proxy StateProxy[C]) StateId {
	selector := GeneticStateSelector[S, C, PS]
	return proxy.FindStateId(selector)
}

// `StateSetupProxy` is a `StateProxy` that can add reactions and set the starting state.
type StateSetupProxy[C any] interface {
	StateProxy[C]
	SetName(string)
	AddReaction(reaction EventReaction)
	SetStartingState(state StateId)
}

func SetStartingState[S any, C any, PS StateCst[S, C]](state StateSetupProxy[C]) {
	id := FindStateId[S, C, PS](state)
	state.SetStartingState(id)
}

func AddSimpleStateTransition[E any, S any, C any, PE EventCst[E], PS StateCst[S, C]](from StateSetupProxy[C], action Action[E, PE]) {
	toId := FindStateId[S, C, PS](from)
	reaction := func(e PE) ReactionResult {
		return from.Transit(toId, ToBaseAction(action))
	}
	from.AddReaction(MakeEventReaction(reaction))
}

func AddCustomStateReaction[E any, C any, PE EventCst[E]](from StateSetupProxy[C], reaction Reaction[E, PE]) {
	from.AddReaction(MakeEventReaction(reaction))
}

func AddInStateReaction[E any, C any, PE EventCst[E]](state StateSetupProxy[C], action Action[E, PE]) {
	reaction := func(e PE) ReactionResult {
		action(e)
		return ReactionResult{status: DISCARD}
	}
	state.AddReaction(MakeEventReaction(reaction))
}

func AddDiscard[E any, C any, PE EventCst[E]](state StateSetupProxy[C], action Action[E, PE]) {
	reaction := func(e PE) ReactionResult {
		return ReactionResult{status: DISCARD}
	}
	state.AddReaction(MakeEventReaction(reaction))
}

// It returns true if the state is of type `*S`
// This is used to find a state by Type
// `S` is the actual user state
// `C` is the user context
// `PS` is deducted (pointer to `S`)
func GeneticStateSelector[S any, C any, PS StateCst[S, C]](state State[C]) bool {
	if _, ok := state.(PS); ok {
		return true
	}
	return false
}

// Default implementation of State[C]
type StateDefault[C any] struct {
	proxy StateProxy[C]
}

func (*StateDefault[C]) isState() bool {
	return true
}
func (s *StateDefault[C]) GetContext() *C {
	return s.proxy.GetContext()
}
func (s *StateDefault[C]) GetAncestor(state StateId) State[C] {
	return s.proxy.GetAncestor(state)
}

// Initializing the state.
func (s *StateDefault[C]) Init(proxy StateProxy[C]) {
	s.proxy = proxy
}

type EventDefault struct {
}

func (e *EventDefault) isEvent() bool {
	return true
}
